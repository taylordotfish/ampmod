#!/usr/bin/env python3
# Copyright (C) 2017 taylor.fish <contact@taylor.fish>
#
# This file is part of Fish AmpMod.
#
# Fish AmpMod is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Fish AmpMod is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Fish AmpMod.  If not, see <http://www.gnu.org/licenses/>.

from collections import OrderedDict
import os

SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
TTL_PATH = os.path.join(SCRIPT_DIR, "ampmod.ttl")
C_PATH = os.path.join(SCRIPT_DIR, "ports.h")
INDENT = " " * 4

TTL_HEAD = """
# Copyright (C) 2017 taylor.fish <contact@taylor.fish>
#
# This file is part of Fish AmpMod.
#
# Fish AmpMod is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Fish AmpMod is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Fish AmpMod.  If not, see <http://www.gnu.org/licenses/>.

# This file was automatically generated by generate_plugin_data.py.

@prefix doap: <http://usefulinc.com/ns/doap#> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix lv2: <http://lv2plug.in/ns/lv2core#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix units: <http://lv2plug.in/ns/extensions/units#> .
@prefix pprops: <http://lv2plug.in/ns/ext/port-props#> .

<https://taylor.fish/plugins/ampmod>
    a lv2:Plugin ,
      lv2:AmplifierPlugin ;
    doap:name "Fish AmpMod" ;
    doap:license <https://www.gnu.org/licenses/gpl-3.0.txt> ;
    doap:developer [
        a foaf:Person ;
        foaf:name "taylor.fish" ;
        foaf:mbox <mailto:contact@taylor.fish> ;
    ] ;
    doap:maintainer [
        a foaf:Person ;
        foaf:name "taylor.fish" ;
        foaf:mbox <mailto:contact@taylor.fish> ;
    ] ;
    lv2:optionalFeature lv2:hardRTCapable ;
    lv2:{strict_bounds_required}Feature pprops:supportsStrictBounds ;
    lv2:port [
"""

C_HEAD = """
/*
 * Copyright (C) 2017 taylor.fish <contact@taylor.fish>
 *
 * This file is part of Fish AmpMod.
 *
 * Fish AmpMod is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Fish AmpMod is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Fish AmpMod.  If not, see <http://www.gnu.org/licenses/>.
 */

// This file was automatically generated by generate_plugin_data.py.

#ifndef PORTS_H
#define PORTS_H

enum {
"""

PORTS = OrderedDict([
    ("INPUT_L", """
a lv2:AudioPort ,
  lv2:InputPort ;
lv2:index {index} ;
lv2:symbol "in0" ;
lv2:name "InL"
"""),

    ("OUTPUT_L", """
a lv2:AudioPort ,
  lv2:OutputPort ;
lv2:index {index} ;
lv2:symbol "out0" ;
lv2:name "OutL"
"""),

    ("INPUT_R", """
a lv2:AudioPort ,
  lv2:InputPort ;
lv2:index {index} ;
lv2:symbol "in1" ;
lv2:name "InR"
"""),

    ("OUTPUT_R", """
a lv2:AudioPort ,
  lv2:OutputPort ;
lv2:index {index} ;
lv2:symbol "out1" ;
lv2:name "OutR"
"""),

    ("EXPONENT", """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "exponent" ;
lv2:name "Exponent" ;
lv2:portProperty pprops:hasStrictBounds ;
lv2:default 1 ;
lv2:minimum 0 ;
lv2:maximum 3.5 ;
"""),

    ("BASE", """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "base" ;
lv2:name "Amplitude base" ;
lv2:portProperty pprops:hasStrictBounds ;
lv2:default 1 ;
lv2:minimum 0 ;
lv2:maximum 1 ;
"""),

    ("INCREMENT", """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "increment" ;
lv2:name "Increment/ms" ;
lv2:portProperty pprops:hasStrictBounds ;
lv2:default 0 ;
lv2:minimum 0 ;
lv2:maximum 0.1 ;
"""),

    ("MIN_MULT", """
a lv2:InputPort ,
  lv2:ControlPort ;
lv2:index {index} ;
lv2:symbol "min_mult" ;
lv2:name "Minimum multiplier" ;
lv2:portProperty pprops:hasStrictBounds ;
lv2:default 0 ;
lv2:minimum 0 ;
lv2:maximum 1 ;
"""),
])


class Writer:
    def __init__(self, ttl_path, c_path):
        self.index = 0
        self.ttl_file = open(ttl_path, "w")
        self.c_file = open(c_path, "w")

    def port(self, c_name, template, first=False, **kwargs):
        if not first:
            self.ttl_raw(INDENT + "] , [")

        self.ttl_raw(INDENT * 2 + template.strip().format(
            index=self.index, **kwargs,
        ).replace("\n", "\n" + INDENT * 2))

        if c_name:
            self.const("PORT_" + c_name, self.index)
        self.index += 1

    def const(self, c_name, val):
        self.c_raw(INDENT + "{} = {},".format(c_name, val))

    def ttl_raw(self, text, **kwargs):
        print(text, file=self.ttl_file, **kwargs)

    def c_raw(self, text, **kwargs):
        print(text, file=self.c_file, **kwargs)

    def close(self):
        pass

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.ttl_file.close()
        self.c_file.close()


def generate_files(writer):
    w = writer
    w.ttl_raw(
        TTL_HEAD.strip().format(
            strict_bounds_required=(
                "required"
                if os.getenv("STRICT_BOUNDS_REQUIRED")
                else "optional"
            ),
        ),
    )
    w.c_raw(C_HEAD.strip())
    for i, (c_name, template) in enumerate(PORTS.items()):
        w.port(c_name, template, first=(i == 0))

    w.ttl_raw(INDENT + "] .")
    w.c_raw("};")
    w.c_raw("")
    w.c_raw("#endif")


def main():
    with Writer(TTL_PATH, C_PATH) as writer:
        generate_files(writer)

if __name__ == "__main__":
    main()
